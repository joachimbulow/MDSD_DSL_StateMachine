/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator



import dk.sdu.mmmi.mdsd.math.MathExp
import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import dk.sdu.mmmi.mdsd.math.Expression
import dk.sdu.mmmi.mdsd.math.num
import dk.sdu.mmmi.mdsd.math.varUse
import dk.sdu.mmmi.mdsd.math.variableInit
import dk.sdu.mmmi.mdsd.math.Multiply
import dk.sdu.mmmi.mdsd.math.Divide
import dk.sdu.mmmi.mdsd.math.Subtract
import dk.sdu.mmmi.mdsd.math.Add
import dk.sdu.mmmi.mdsd.math.Variables
import java.util.List

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	static Map<String, Integer> variables = new HashMap();
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val debug = resource.allContents
		val allVariables = resource.allContents.filter(Variables).next
		
		val result = allVariables.compute
		
		// You can replace with hovering, see Bettini Chapter 8
		result.displayPanel
	}
	
	
	def static compute(Variables v) { 
		
		for (MathExp mathExp : v.variables) {
			val i = mathExp.exp.computeExp(variables)
			variables.put(mathExp.name, i)
		}
		
		return variables
	}
	
	//Divide by 0?
	def static int computeExp(Expression exp, Map<String, Integer> vars) {
		switch exp {
			Add: exp.left.computeExp(vars) + exp.right.computeExp(vars)
			Subtract: exp.left.computeExp(vars) - exp.right.computeExp(vars)
			Multiply: exp.left.computeExp(vars) * exp.right.computeExp(vars)
			Divide: exp.left.computeExp(vars) / exp.right.computeExp(vars)
			num: exp.value
			//varUse: exp.inExp.exp.computeExp(vars)
			varUse: vars.get(exp.inExp.name)
			variableInit: exp.statement.computeExp(vars.appendToMap(exp.name, exp.init.computeExp(vars)))
			default: -999999
		}
	}
	
	def static Map<String, Integer> appendToMap(Map<String, Integer> map, String name, int value){
		val temp = new HashMap<String, Integer>(map);
		temp.put(name, value);
		return temp;
	}
	
	
	def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
         	resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
        }
		
		JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
	

}
