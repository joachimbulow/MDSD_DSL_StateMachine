/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.LetBinding
import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.MathNumber
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.VarBinding
import dk.sdu.mmmi.mdsd.math.VariableUse
import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.Program
import dk.sdu.mmmi.mdsd.math.ExternalCall
import java.util.ArrayList
import java.util.Arrays

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val program = resource.allContents.filter(Program).next
		fsa.generateFile(
            "math_expression/" + program.name + ".java",
            program.compile);
		
	}
	
	static ArrayList<String> variables = new ArrayList<String>(Arrays.asList("n", "m", "o", "p"));
	static int index = 0;
	
	def static compile(Program program) {
		'''
			package math_expression;
			public class «program.name» {
			
			«FOR variable : program.math.variables»
			public int «variable.name»;
			 «ENDFOR»
			
			«IF program.externals.size > 0»
				private External external;
			«ENDIF»
			  
			  
			  «IF program.externals.size > 0»
			   	public «program.name» (External external) {
			   	this.external = external;
			   		}
			  «ENDIF»
			 
			
			  public void compute() {
			    «FOR variable : program.math.variables»
			    «variable.name» = «variable.expression.compileExpression»;
			     «ENDFOR»
			  }
			
			«IF program.externals.size > 0»
			 interface External {
				 «FOR external : program.externals»
				 public int «external.name»( «FOR type : external.types SEPARATOR ', '»«type» «variables.get(index++)» «ENDFOR»);
				 «ENDFOR»
				 
			}
			«ENDIF»
			}
		'''
	}
	
	def static dispatch String compileExpression(VarBinding binding) {
			compileExpression(binding.expression)
		}
	
	
	def static dispatch String compileExpression(MathNumber exp) {
		exp.value.toString()
	}

	def static dispatch String compileExpression(Plus exp) {
		'''«exp.left.compileExpression» + «exp.right.compileExpression»'''
	}
	
	def static dispatch String compileExpression(Minus exp) {
		'''«exp.left.compileExpression» - «exp.right.compileExpression»'''
	}
	
	def static dispatch String compileExpression(Mult exp) {
		'''«exp.left.compileExpression» * «exp.right.compileExpression»'''
	}
	
	def static dispatch String compileExpression(Div exp) {
		'''«exp.left.compileExpression» / «exp.right.compileExpression»'''
	}
	
	def static dispatch String compileExpression(LetBinding exp) {
		var bindingresult = exp.binding.compileExpression 
		var bodyresult = exp.body.compileExpression
		var gg = bodyresult.replaceAll(exp.name, bindingresult)
		return gg;
	}

	def static dispatch String compileExpression(VariableUse exp) {
		var ref =  exp.ref;
		if (ref instanceof LetBinding) {
			ref.binding.compileExpression
		}
		return  '''«exp.ref.name»'''
		
	}
	
	def static dispatch String compileExpression(ExternalCall exp) {
		'''this.external.«exp.external.name»( «FOR argument : exp.arguments»«argument.compileExpression»«IF argument != exp.arguments.last»,«ENDIF» «ENDFOR»)'''
	}

//	def static dispatch String computeExpression(LetBinding exp) {
//		exp.body.computeExpression
//	}
//	
//	def static dispatch String compileExpression(VariableUse exp) {
//		exp.ref.computeBinding
//	}
//
//	def static dispatch String computeBinding(VarBinding binding){
//		if(!variables.containsKey(binding.name))
//			binding.compileExpression			
//		variables.get(binding.name).toString()
//	}
//	
//	def static dispatch String computeBinding(LetBinding binding){
//		binding.binding.compileExpression
//	}
	
}
